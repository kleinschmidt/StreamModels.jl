```{julia; echo=false}
using Weave
set_chunk_defaults(Dict{Symbol,Any}(:term=>true))
```

# StreamModels

[![Build Status](https://travis-ci.org/kleinschmidt/StreamModels.jl.svg?branch=master)](https://travis-ci.org/kleinschmidt/StreamModels.jl)
[![codecov.io](http://codecov.io/github/kleinschmidt/StreamModels.jl/coverage.svg?branch=master)](http://codecov.io/github/kleinschmidt/StreamModels.jl?branch=master)

This is a prototype of a different approach to generating numerical model
matrices based on tabular data and a formula.  It works with any data source
that satisfies
the
[DataStreams `Data.Source` interface](http://juliadata.github.io/DataStreams.jl/stable/),
including in-memory stores like DataFrames/DataTables, as well as databases and
files on disk like CSV and Feather.

At the moment, the interface is minimal: a `modelmatrix` function that takes a
a `Data.Source` and a `Formula`

## Examples

### DataFrame source

```{julia; term=true}
using DataFrames, StreamModels, CSV
using StreamModels: @formula    # because it's exported by DataFrames
source = CSV.read(Pkg.dir("StreamModels", "test", "test.csv"))
mm = modelmatrix(source, @formula( ~ a*b*c))
```

Note that there's no intercept by default, and hence the contrasts for the first
`c` term are properly promoted to "full rank" dummy coding.

### Arbitrary functions

Using code generation means we can (again) use arbitrary julia code in the
formula:

```{julia; term=true}
modelmatrix(source, @formula(~1 + a + b + log(a) + log(a+b)))
```

### CSV source

For any source that's not random access, need to add a `reset!` method (until
that's part of the Data.Source interface).

```{julia; term=true}
StreamModels.reset!(x::CSV.Source) = CSV.reset!(x)
csv_source = CSV.Source(Pkg.dir("StreamModels", "test", "test.csv"))
modelmatrix(csv_source, @formula( ~ a*b*c))
```

## Strategy

The general strategy is 

### Parse the formula

Given an expression, it's transformed into a form where all the special forms
(like `*`) are expanded, and the associative/distributive rules are applied
where appropriate (for `+` and `&`).  This is based on `StatsModels` but uses a
slightly different approach.

```{julia; term=true}
using StreamModels: parse!
f = parse!(@formula( ~ a*b*c))
```

### Set the schema in the formula

Given a data source, we need to extract its schema and combine it with the
Formula.  This is done by transforming symbol nodes in the formula AST into
special representations of terms to be evaluated from the data, `ContinuousTerm`
or `CategoricalTerm`.  This requires first making one pass through the data to
get the unique values for categorical columns, which are then stored in the
schema metadata.  At this phase contrasts matrices are constructed for
categorical variables and stored on the `CategoricalTerm`s.

This stage requires both the data schema and the parsed formula because we need
to know the types of the variables _and_ whether any given term "aliases" lower
order terms in order to know which contrasts to use.

For now, we rely on a special wrapper for a `Data.Source` which provides an
iterator over tuples that unwraps `Nullable` values (because the state of
nullables is up in the air and I'm lazy).

```julia
using StreamModels: tuple_iterator, get_unique!, set_schema!
iter = get_unique!(tuple_iterator(source), [:c])
sch = Data.schema(iter); set_schema!(f, sch)
```

### Generate an anonymous function to fill one row at a time

This step is handled by the `AnonFactory` type, which holds onto the metadata
required to generate code for each of the terms in the formula, as well as the
generated expressions themselves.

```julia
using StreamModels: AnonFactory, get_symbols, model_function_exp
col_nums = Dict(s=>sch[string(s)] for s in get_symbols(f))
af = AnonFactory(f.rhs, col_nums);
fill_row! = Function(af)
```

You can get the expression that's `eval`ed to get the actual function with

```julia
model_function_exp(af)
```

This function takes two arguments: a row vector to fill, and a tuple for the
corresponding table row.  Main effects of continuous variables are just copied
over to the output vector.  Interactions are generated via kronecker product of
the main effects (reducing to multiplication for continuous terms).  Categorical
values are converted to the correct row of a contrasts matrix and copied to the
output.  The categorical pools and contrast matrices are spliced into a `let`
block that surrounds the body of the function.

Using code generation allows for arbitrary functions and, in principle, to
customize based on the back end, without making strong assumptions about the
structure of the data store.  There's a small overhead from needing to compile
this function, but that's paid only once per model matrix.

