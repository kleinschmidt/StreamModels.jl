

################################################################################
# Now we have a Formula with a vector of Terms that are typed.  We just need to
# have a generated function that generates the code for filling in a single
# model matrix row (similar to what AnonFactory does).  This requires knowing
# the number of columns generated by each term (`nc`).

"""
    nc(t::Type{T}) where T <: Terms.Term

Return the number of columns generated by a term of type `t`.  For `Continuous`,
`Intercept`, and `FunctionTerm`, this is 1.  For `Categorical`, it's the size of
the contrasts matrix.  For an `Interaction` term, it's the product of the number
of columns generated by the children terms.  For an `Eval` term, an error is
thrown (since it can't be determined).

For a custom term type, you need to provide an `nc` method as well as a
`rowval` method.


"""
nc(t::Type{Terms.Eval}) =
    throw(ArgumentError("can't compute number of columns generated by un-typed " *
                        "Eval term $t. Did you forget to `set_schema`?"))
nc(::Type{Terms.Term}) = 0
nc(::Type{Terms.Intercept}) = 1
nc(::Type{Terms.Continuous}) = 1
nc(::Type{Terms.FunctionTerm}) = 1 # TODO: is this right? should we handle n-ary functions?
nc(::Type{Terms.Categorical{N}}) where N = N
nc(::Type{Terms.Interaction{T}}) where T = mapreduce(nc, *, T.parameters)


@generated function modelmatrow!(row::AbstractVector, data::NamedTuple, terms::Tuple)
    Ts = collect(terms.parameters)
    cols = mapreduce(nc, +, Ts)
    println("$cols columns")
    println("Terms:")
    map(println, Ts)

    func_body = Expr(:block)
    ci = 0
    for ti in eachindex(Ts)
        starti, ci = ci+1, ci+nc(Ts[ti])
        push!(func_body.args, :(row[$starti:$ci] = rowval(data, terms[$ti])))
    end
    push!(func_body.args, :(row))
    println(func_body)
    return func_body
end

@generated function modelmatrow(data::NamedTuple, terms::Tuple)
    Ts = collect(terms.parameters)
    cols = mapreduce(nc, +, Ts)
    :(modelmatrow!(Array{Float64}($cols), data, terms))
end


# need to generate expressions like :(row[1] = data[terms[1].name])
rowval(data::NamedTuple, ::Terms.Intercept) = 1
rowval(data::NamedTuple, t::Terms.Continuous) = data[t.name]
rowval(data::NamedTuple, t::Terms.Categorical) =
    t.contrasts.matrix[t.invindex[data[t.name]], :]
@generated function rowval(data::NamedTuple, t::Terms.Interaction)
    nterms = length(t.parameters[1].parameters)
    out_ex = Expr(:call, :kron)
    for ti in 1:nterms
        push!(out_ex.args, :(rowval(data, t.terms[$ti])))
    end
    out_ex
end
rowval(data::NamedTuple, t::Terms.FunctionTerm) = t.f(data)
